<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018NOI导刊被虐记]]></title>
    <url>%2F2018%2F07%2F18%2F2018NOI%E5%AF%BC%E5%88%8A%E8%A2%AB%E8%99%90%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[序言过程Day0好像我是比较晚和大家在火车站集合的，为了一个舒适的路程，特意买的是高铁票（为此还放弃了直达票）高铁上还是比较舒适的，有电有网有吃，十几个人把电脑打开，俨然一个高档网吧（误） Day1Day2Day3Day4Day5Day6Day7Day8后记]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[B君的病症]]></title>
    <url>%2F2018%2F07%2F17%2FB%E5%90%9B%E7%9A%84%E7%97%85%E7%97%87%2F</url>
    <content type="text"><![CDATA[题目题目描述享国之日浅，国家无事。B 君看到了 Z 君的第二题，觉得很难。 于是自己出了一个简单题。 大 A 是一名强迫症患者，现在他要给一群带颜色的珠子排成一列，现在有 n 种颜色，其中第 i 种颜色的珠子有 ai 个。要求排列中第 i 种颜色珠子的所有珠子，一定要排在第 i + 1 种颜色的第一个和最后一个珠子之间。问有多少种排列珠子的方案，因为方案数会很大，所以请输出答案对1000000007 取模之后的结果。 输入格式第一行一个整数 n。 以下 n 行，每行一个整数 ai。 输出格式一行一个整数表示答案。 输入样例12343244 输出样例1168 说明对于 100% 的数据，满足 1 ≤ n ≤ 10^4 , 2 ≤ ai ≤ 15。 对于 70% 的数据，满足 1 ≤ n ≤ 10^2。 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define MOD 1000000007#define MAXN 100001long long fact[MAXN],inv[MAXN];long long pow(long long a,long long b)&#123; long long ans=1; while(b)&#123; if(b&amp;1)ans=a*ans%MOD; a=a*a%MOD; b&gt;&gt;=1; &#125; return ans%MOD;&#125;long long c(long long m,long long n)&#123; return fact[m]*inv[n]%MOD*inv[m-n]%MOD;&#125;void pre()&#123; fact[0]=1; inv[0]=1; for(int i=1;i&lt;MAXN;i++)&#123; fact[i]=fact[i-1]*i%MOD; inv[i]=pow(fact[i],MOD-2); &#125;&#125;int main()&#123; long long x,y; pre(); cin&gt;&gt;x; long long z=1; int s=0; for(int i=1;i&lt;=x;i++)&#123; scanf("%lld",&amp;y); z=z*c(s+y-2,y-2)%MOD; s+=y; &#125; cout&lt;&lt;z; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[poj1845]Sumdiv]]></title>
    <url>%2F2018%2F07%2F09%2F%5Bpoj1845%5DSumdiv%2F</url>
    <content type="text"><![CDATA[题目题目描述Consider two natural numbers A and B. Let S be the sum of all natural divisors of A^B. Determine S modulo 9901 (the rest of the division of S by 9901). 输入The only line contains the two natural numbers A and B, (0 &lt;= A,B &lt;= 50000000)separated by blanks. 输出The only line of the output will contain S modulo 9901. 样例输入12 3 样例输出115 提示$ 2^3 = 8. $The natural divisors of 8 are: 1,2,4,8. Their sum is 15.15 modulo 9901 is 15 (that should be output). 来源Romania OI 2002 传送门Sumdiv 题解问题分析刚一看到这个题，一股浓浓的数论感就扑面而来，求$ A^B $的约数和，暴力当然是不可取的，我们不妨换个角度如果我们把$ A $分解质因数，表示为 $$ A=p_1^(c_1)p_2^(c_2)p_3^(c_3)…p_n^(c_n) $$ 那么$ A^B $可表示为$$ A=p_1^(Bc_1)p_2^(Bc_2)p_3^(Bc_3)…p_n^(Bc_n) $$则$ A^B $所有约数和为$$ (1+p_1+p_1^2+…+p_1^(Bc_1)) $$ 质因数分解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50001const int MOD=9901;long long a,b;long long p[MAXN],c[MAXN];long long m;long long ans; long long pow(long long p,long long n)&#123; long long sq=1; while(n)&#123; if(n&amp;1)sq=(sq*p)%MOD; n&gt;&gt;=1; p=(p*p)%MOD; &#125; return sq;&#125; bool prime(int n)&#123; if(n&lt;2)return 0; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0)return 0; &#125; return 1;&#125; void divide(int n)&#123; m=0; for(int i=2;i&lt;=sqrt(n);i++)&#123; if(n%i==0&amp;&amp;prime(i))&#123; p[++m]=i,c[m]=0; while(n%i==0)n/=i,c[m]++; &#125; &#125; if(n&gt;1&amp;&amp;prime(n))p[++m]=n,c[m]=1; return;&#125; long long sum(long long p,long long c)&#123; if(c==0)return 1; if(c%2==0)return (sum(p,c/2-1)*(1+pow(p,c/2+1))+pow(p,c/2))%MOD; else return (sum(p,c/2)*(1+pow(p,c/2+1)))%MOD;&#125; void work()&#123; ans=1; for(int i=1;i&lt;=m;i++)&#123; ans=(ans*sum(p[i],c[i]*b)%MOD)%MOD; &#125;&#125; int main()&#123; cin&gt;&gt;a&gt;&gt;b; divide(a); work(); printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[poj3263]Tallest Cow]]></title>
    <url>%2F2018%2F07%2F09%2F%5Bpoj3263%5DTallest%20Cow%2F</url>
    <content type="text"><![CDATA[题目题目描述FJ’s N (1 ≤ N ≤ 10,000) cows conveniently indexed 1..N are standing in a line. Each cow has a positive integer height (which is a bit of secret). You are told only the height H (1 ≤ H ≤ 1,000,000) of the tallest cow along with the index I of that cow. FJ has made a list of R (0 ≤ R ≤ 10,000) lines of the form “cow 17 sees cow 34”. This means that cow 34 is at least as tall as cow 17, and that every cow between 17 and 34 has a height that is strictly smaller than that of cow 17. For each cow from 1..N, determine its maximum possible height, such that all of the information given is still correct. It is guaranteed that it is possible to satisfy all the constraints. 输入Line 1: Four space-separated integers: N, I, H and RLines 2..R+1: Two distinct space-separated integers A and B (1 ≤ A, B ≤ N), indicating that cow A can see cow B. 输出Lines 1..N: Line i contains the maximum possible height of cow i. 输入样例1234569 3 5 51 35 34 33 79 8 输出样例123456789545344555 来源USACO 2007 January Silver 传送门Tallest Cow 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;int d[100001];unsigned int s[100001];int n,i,h,r;int x,y;map&lt;pair&lt;int,int&gt;,bool&gt; judge; int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;i,&amp;h,&amp;r); d[1]=h; for(int i=1;i&lt;=r;i++)&#123; scanf("%d%d",&amp;x,&amp;y); if(x&gt;y)swap(x,y); if(judge[make_pair(x,y)])continue; d[x+1]--,d[y]++; judge[make_pair(x,y)]=1; &#125; for(int i=1;i&lt;=n;i++)&#123; s[i]=s[i-1]+d[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d\n",s[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2003]激光炸弹]]></title>
    <url>%2F2018%2F07%2F09%2F%5BHNOI2003%5D%E6%BF%80%E5%85%89%E7%82%B8%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[题目题目描述一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n(N&lt;=10000)个目标，用整数Xi,Yi(其值在[0,5000])表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。 输入输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示xi,yi,vi 输出输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过32767）。 输入样例1232 10 0 11 1 1 输出样例11 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,R;int a[5002][5002];int ans; int main()&#123; cin&gt;&gt;n&gt;&gt;R; for(int i=1;i&lt;=n;i++)&#123; int x,y,num; scanf("%d%d%d",&amp;x,&amp;y,&amp;num); a[y+1][x+1]=num; &#125; for(int i=1;i&lt;=5001;i++)&#123; for(int j=1;j&lt;=5001;j++)&#123; a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]; &#125; &#125; for(int i=R;i&lt;=5001;i++)&#123; for(int j=R;j&lt;=5001;j++)&#123; int tmp=a[i][j]-a[i-R][j]-a[i][j-R]+a[i-R][j-R]; if(ans&lt;tmp)ans=tmp; &#125; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1880][NOI1995]石子合并]]></title>
    <url>%2F2018%2F07%2F05%2F%5B%E6%B4%9B%E8%B0%B7P1880%5D%5BNOI1995%5D%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目题目描述在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分. 输入格式数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数. 输出格式输出共2行,第1行为最小得分,第2行为最大得分. 样例输入1244 5 9 4 样例输出124354 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 402using namespace std;int fmin[MAXN][MAXN];int sum[MAXN];int fmax[MAXN][MAXN];int n;int main()&#123; memset(fmin,0x3f,sizeof(fmin)); memset(fmax,0,sizeof(fmax)); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int a; scanf("%d",&amp;a); fmin[i][i]=0; fmin[i+n][i+n]=0; sum[i]=sum[i-1]+a; &#125; for(int i=1;i&lt;=n;i++)&#123; sum[i+n]=sum[n]+sum[i]; &#125; for(int len=2;len&lt;=n;len++)&#123; for(int i=1;i&lt;=n+n-len+1;i++)&#123; int j=i+len-1; for(int k=i;k&lt;j;k++)&#123; fmax[i][j]=max(fmax[i][j],fmax[i][k]+fmax[k+1][j]+sum[j]-sum[i-1]); fmin[i][j]=min(fmin[i][j],fmin[i][k]+fmin[k+1][j]+sum[j]-sum[i-1]); &#125; &#125; &#125; int minn=1&lt;&lt;30; int maxx=0; for(int i=1;i&lt;=n;i++)&#123; minn=min(minn,fmin[i][i+n-1]); maxx=max(maxx,fmax[i][i+n-1]); &#125; printf("%d\n%d",minn,maxx); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>环状dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1049]装箱问题]]></title>
    <url>%2F2018%2F07%2F04%2F%5B%E6%B4%9B%E8%B0%B7P1049%5D%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目题目描述有一个箱子容量为 V （正整数，$ 0 &lt;= V &lt;=20000 $），同时有 n 个物品（ $ 0&lt;n&lt;=30 $ ，每个物品有一个体积（正整数）。 要求 nn 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。注：此问题区分大小写 输入格式1 个整数，表示箱子容量 1 个整数，表示有 n 个物品 接下来 n 行，分别表示这 n 个物品的各自体积 输出格式1个整数，表示箱子剩余空间。 样例输入123456782468312797 样例输出10 来源NOIp2001普及组 第4题 题解代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,v;int w[31];int f[20001];int main()&#123; scanf("%d%d",&amp;v,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;w[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=v;j&gt;=w[i];j--)&#123; f[j]=max(f[j],f[j-w[i]]+w[i]); &#125; &#125; printf("%d",v-f[v]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1435]回文字串]]></title>
    <url>%2F2018%2F07%2F04%2F%5B%E6%B4%9B%E8%B0%B7P1435%5D%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目题目描述回文词是一种对称的字符串。任意给定一个字符串，通过插入若干字符，都可以变成回文词。此题的任务是，求出将给定字符串变成回文词所需要插入的最少字符数。 比如 “Ab3bd”插入2个字符后可以变成回文词“dAb3bAd”或“Adb3bdA”，但是插入少于2个的字符无法变成回文词。 注：此问题区分大小写 输入格式一个字符串(0&lt;strlen&lt;=1000) 输出格式有且只有一个整数，即最少插入字符数 样例输入1Ab3bd 样例输出12 来源IOI2000第一题 题解这里有个易错点，关于strlen函数的。 strlen()函数其实就是个计数器，它会从字符串开头，到终止符结束，最后返回结果。 但是，有些时候我们为了方便，会在读入字符串的时候使用scanf(“%s”,a+1)这时候，strlen(a)的返回值一定是0，因为a字符串的开头就是终止符，正确做法strlen(a+1) 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char str[5001];int n;int f[5001][5001];int main()&#123; cin&gt;&gt;str+1; n=strlen(str+1); for(int len=1;len&lt;=n;len++)&#123; for(int i=1;i&lt;=n-len+1;i++)&#123; int j=i+len-1; if(str[i]==str[j])f[i][j]=f[i+1][j-1]; else f[i][j]=min(f[i+1][j],f[i][j-1])+1; &#125; &#125; printf("%d",f[1][n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[hdu1114]猪猪储蓄罐]]></title>
    <url>%2F2018%2F07%2F03%2F%5BYZOJ1582%5D%E7%8C%AA%E7%8C%AA%E5%82%A8%E8%93%84%E7%BD%90%2F</url>
    <content type="text"><![CDATA[我写的是单输入版本，改一下应该不会超时 题目题目描述Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! 输入格式The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams. 输出格式Print exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”. 样例输入12345678910111213310 11021 130 5010 11021 150 301 6210 320 4 样例输出123The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. 来源Central Europe 1999 题解代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int e,F,s;int n;int p[10001],w[10001];int f[10001];const int inf=0x3f3f3f3f;int main()&#123; scanf("%d%d",&amp;e,&amp;F); s=F-e; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;p[i],&amp;w[i]); f[i]=inf; &#125; f[0]=0; for(int i=1;i&lt;=s;i++)f[i]=inf; for(int i=1;i&lt;=n;i++)&#123; for(int v=w[i];v&lt;=s;v++)&#123; f[v]=min(f[v],f[v-w[i]]+p[i]); &#125; &#125; if(f[s]==inf)printf("This is impossible."); else printf("The minimum amount of money in the piggy-bank is %d.",f[s]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2006]受欢迎的牛]]></title>
    <url>%2F2018%2F06%2F21%2F%5BHAOI2006%5D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[题目题目描述每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。 这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。 输入第一行两个数N,M。 接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B） 输出一个数，即有多少头牛被所有的牛认为是受欢迎的。 样例输入12343 31 22 12 3 样例输出11 提示100%的数据N&lt;=10000,M&lt;=50000 题解虽然网上有不少题解，但我觉得还是自己写下，毕竟题解这东西首先是写给自己的。 缩点 分析假如你已经完全搞懂了tarjan的话可以直接看这里。当我们把所有的强连通分量分别合并到一个点里（每次标记出栈的点，这些点就在同一个强连通分量里），不难发现，统计每一个点的出度，如果有1个点出度为0，那么这个点里的所有牛就是最受欢迎的了，其他情况则没有最受欢迎的牛，如图： tarjan算法tarjan算法用来寻找有向图的强连通分量的算法，它可以在$ O(|V|+|E|) $ 的时间内得出结果。下面内容大部分来源于这篇文章。 为了更好地理解tarjan算法是如何通过dfs来求强连通分量的，我们这里不妨先了解下搜索树。比如这是一个有向图： 而他的搜索树长这样： 从图中我们可以看到3种边（实际上有4种，但是其实第四种只要和第一种一样处理就可以了） 1.实线画出来的是树边，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。2.用长虚线画出来的是反祖边，也被叫做回边,它主要是在搜索的时候遇到了一个已经访问过的结点，而且这个结点是当前节点的祖先时形成的。3.用短虚线画出来的是横叉边，它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点不是当前节点的祖先时形成的。 现在我们来看看在 DFS 的过程中强连通分量有什么性质。 很重要的一点是如果结点 u 是某个强连通分量在搜索树中遇到的第一个结点（这通常被称为这个强连通分量的根），那么这个强连通分量的其余结点肯定是在搜索树中以 u 为根的子树中。如果有个结点 v 在该强连通分量中但是不在以 u 为根的子树中，那么 u 到 v 的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和 u 是第一个访问的结点矛盾了。 Tarjan 算法主要是在 DFS 的过程中维护了一些信息：dfn、low 和一个栈。 栈里的元素表示的是当前已经访问过但是没有被归类到任一强连通分量的结点。 dfn[u] 表示结点 u 在 DFS 中第一次搜索到的次序，通常被叫做时间戳。 low[u] 稍微有些复杂，它表示从 u 或者以 u 为根的子树中的结点，再通过一条反祖边或者横叉边可以到达的时间戳最小的结点 v 的时间戳，并且要求 v 有一些额外的性质：v 还要能够到达 u。显然通过反祖边到达的结点 v 满足 low 的性质，但是通过横叉边到达的却不一定。可以证明，结点 u 是某个强连通分量的根等价于 dfn[u] 和 low[u] 相等。简单可以理解成当它们相等的时候就不可能从 u 通过子树再经过其它时间戳比它小的结点回到 u。 当通过 u 搜索到一个新节点 v 的时候可以有多种情况： $ 1° $ 结点 u 通过树边到达结点 v$$ low[u]=min(low[u],low[v]) $$ $ 2° $ 结点 u 通过反祖边到达结点 v，或者通过横叉边到达结点 v 并且满足 low 定义中 v 的性质$$ low[u]=min(low[u],dfn[v]) $$ 如果 dfn 和 low 相等，那么就不断退栈直到当前结点为止，这些结点就属于一个强连通分量。 至于如何更新 low，关键就在于第二种情况，当通过反祖边或者横叉边走到一个结点的时候，只需要判断这个结点是否在栈中，如果在就用它的 low 值更新当前节点的 low 值，否则就不更新。因为如果不在栈中这个结点就已经确定在某个强连通分量中了，不可能回到 u。 附：链式前向星代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 50001int E[MAXN],low[MAXN],Next[MAXN],Head[MAXN],dfn[MAXN],num=0,count,out[MAXN],o,how_many[MAXN],chudu[MAXN],zhan[MAXN],top=0;bool v[MAXN],chuzhan[MAXN];void add(int x,int y,int i)&#123; E[i]=y; Next[i]=Head[x]; Head[x]=i;&#125;int find()&#123; int ans=0; for(int i=1;i&lt;=o;i++)&#123; for(int p=Head[out[i]];p;p=Next[p])&#123; if(!chuzhan[E[p]])&#123; ans++; &#125; &#125; &#125; return ans;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++num; zhan[++top]=u; v[u]=1; for(int p=Head[u];p;p=Next[p])&#123; int y=E[p]; if(!dfn[y])&#123; tarjan(y); low[u]=min(low[y],low[u]); &#125;else&#123; if(v[y])low[u]=min(low[u],dfn[y]); &#125; &#125; if(dfn[u]==low[u])&#123; int y; count++; do&#123; y=zhan[top--]; v[y]=0; out[++o]=y; chuzhan[y]=1; how_many[count]++; &#125;while(y!=u); chudu[count]=find(); o=0; memset(chuzhan,0,sizeof(chuzhan)); &#125;&#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); add(x,y,i); &#125; for(int i=1;i&lt;=n;i++)&#123; if(!dfn[i])tarjan(i); &#125; int c=0,ans; for(int i=1;i&lt;=count;i++)&#123; if(!chudu[i])c++,ans=i; &#125; if(c==1)cout&lt;&lt;how_many[ans]; else cout&lt;&lt;"0"; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>图的连通</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P2820]局域网]]></title>
    <url>%2F2018%2F06%2F17%2F%5B%E6%B4%9B%E8%B0%B7P2820%5D%E5%B1%80%E5%9F%9F%E7%BD%91%2F</url>
    <content type="text"><![CDATA[题目题目背景某个局域网内有n(n&lt;=100)台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用f(i,j)表示i,j之间连接的畅通程度，f(i,j)值越小表示i,j之间连接越通畅，f(i,j)为0表示i,j之间无网线连接。 题目描述需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的Σf(i,j)最大，请求出这个最大值。 输入格式第一行两个正整数n k接下来的k行每行三个正整数i j m表示i,j两台计算机之间有网线联通，通畅程度为m。 输出格式一个正整数，Σf(i,j)的最大值。 输入样例1234565 51 2 81 3 11 5 32 4 53 4 2 输出样例18 说明f(i,j)&lt;=1000 题解这里可以采用存边的方法存储图，再用克鲁斯卡尔按边求出最小生成树，把这些边标记起来，再把没有标记过的相加，这样做的好处是避免数据溢出（当然你也可以开长整型） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct Tedge&#123; int from; int to; int num;&#125;edge[10001];int father[101];//并查集bool Ebook[10001];int n,k,ans;int find(int x)&#123; if(x==father[x])return x; return find(father[x]);//这里一定要有return&#125;void solve()&#123; for(int i=1;i&lt;=k;i++)&#123; int f1,f2; f1=find(edge[i].from); f2=find(edge[i].to); if(f1!=f2)&#123; father[f1]=f2; Ebook[i]=1; &#125; &#125;&#125;bool cmp(Tedge a,Tedge b)&#123; return a.num&lt;b.num;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)father[i]=i; for(int i=1;i&lt;=k;i++)&#123; scanf("%d %d %d",&amp;edge[i].from,&amp;edge[i].to,&amp;edge[i].num); &#125; sort(edge+1,edge+k+1,cmp);//求最小生成树，边由小到大 solve(); for(int i=1;i&lt;=k;i++)if(Ebook[i]==0)ans+=edge[i].num; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>kruskal</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[洛谷P1908]逆序对]]></title>
    <url>%2F2018%2F06%2F17%2F%5B%E6%B4%9B%E8%B0%B7P1908%5D%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 输入格式第一行，一个数n，表示序列中有n个数。第二行n个数，表示给定的序列。 输出格式给定序列中逆序对的数目。 输入样例1265 4 2 6 3 1 输出样例111 说明对于50%的数据，n≤2500对于100%的数据，n≤40000。 题解树状数组既然名字都叫树状数组，那么肯定是和数有关的咯，我们来先看一个二叉树 我们来稍微变下形 现在我们把树状数组c[]摆放到每一列的顶端 C[i]代表子树的叶子结点的权值之和我们通过这张图可以知道$$ C[1]=A[1]; $$$$ C[2]=A[1]+A[2]; $$$$ C[3]=A[3]; $$$$ C[4]=A[1]+A[2]+A[3]+A[4]; $$$$ C[5]=A[5]; $$$$ C[6]=A[5]+A[6]; $$$$ C[7]=A[7]; $$$$ C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; $$通过分情况讨论好像是有什么规律，那有没有更一般的规律呢？我们不妨将树状数组的编号转换成二进制看看$$ 1=(001)—C[1]=A[1]; $$$$ 2=(010)—C[2]=A[1]+A[2]; $$$$ 3=(011)—C[3]=A[3]; $$$$ 4=(100)—C[4]=A[1]+A[2]+A[3]+A[4]; $$$$ 5=(101)—C[5]=A[5]; $$$$ 6=(110)—C[6]=A[5]+A[6]; $$$$ 7=(111)—C[7]=A[7]; $$$$ 8=(1000)—C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; $$ 对照式子可以发现 C[i]=A[i-2^k+1]+A[i-2^k+2]+……A[i]; （k为i的二进制中从最低位到高位连续零的长度）例如i=8时，k=3。 而lowbit(x)函数的作用就是取出x的最低位。 树状数组的优点在于单点更新以及区间查询，对于求逆序对来说，知道一个数的位置x，那么1~x范围内就是比它小的数，而用已经插入的数的个数减去这个数，累加起来就是我们要算的逆序对数。 离散化上面提到我们要知道一个数的位置，可以用树状数组下标来表示$ c[x] $，但整型范围很大,不可能开这么大的数组，所以我们只需要保留它们的相对大小，用离散化处理。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 100001using namespace std;int n;struct node&#123; int num,index;&#125;a[MAXN];int c[MAXN];//树状数组int A[MAXN];//离散化后的数组int low_bit(int i)&#123; return i&amp;(-i);&#125;void update(int i,int v)//插入&#123; while(i&lt;=n)&#123; c[i]+=v; i+=low_bit(i); &#125;&#125;int get_sum(int i)//区间查找&#123; int res=0; while(i)&#123; res+=c[i]; i-=low_bit(i); &#125; return res;&#125;bool cmp(node a,node b) &#123; return a.num&lt;b.num; &#125; int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].num); a[i].index=i; &#125; sort(a+1,a+1+n,cmp); int p=0; for(int i=1;i&lt;=n;i++)&#123; /*if(a[i].num!=a[i-1].num)p++; A[a[i].index]=p;*///如果数据中存在重复数据才需要 A[a[i].index]=i;//离散化 &#125; long long ans=0; for(int i=1;i&lt;=n;i++)&#123; update(A[i],1);//插入 ans+=i-get_sum(A[i]); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POJ-3264] Balanced Lineup]]></title>
    <url>%2F2018%2F06%2F16%2F%5BPOJ-3264%5D%20Balanced%20Lineup%2F</url>
    <content type="text"><![CDATA[注：数据改编自原题，输入输出略有不同 题目题目描述For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height. Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group. 输入Line 1: Two space-separated integers, N and Q.Lines 2..N+1: Line i+1 contains a single integer that is the height of cow iLines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive. 输出Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range. 样例输入123456789106 31734251 54 62 2 样例输出123630 题解ST表代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50001int n,q;int stmin[MAXN][20];int stmax[MAXN][20];void pre_work()&#123; for(int j = 1; j &lt; 20; ++j) for(int i = 1; i &lt;= n; ++i) if(i + (1 &lt;&lt; j) - 1 &lt;= n)&#123; stmax[i][j] = max(stmax[i][j-1], stmax[i + (1 &lt;&lt; (j - 1))][j - 1]); stmin[i][j] = min(stmin[i][j-1], stmin[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++)&#123; scanf("%d", &amp;stmin[i][0]); stmax[i][0]=stmin[i][0]; &#125; pre_work(); for(int i=1;i&lt;=q;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); int k=(int)(log(y - x + 1.0) / log(2.0)); int maxsum = max(stmax[x][k], stmax[y - (1 &lt;&lt; k) + 1][k]); int minsum = min(stmin[x][k], stmin[y - (1 &lt;&lt; k) + 1][k]); printf("%d\n",maxsum-minsum); &#125; return 0;&#125; 线段树代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define MAXN 50001int n,q;struct Ttree&#123; int maxdata,mindata;&#125;t[MAXN*4],tmp0;void push_up(int l,int r,int k)&#123; t[k].maxdata=max(t[k*2].maxdata,t[k*2+1].maxdata); t[k].mindata=min(t[k*2].mindata,t[k*2+1].mindata);&#125;void make(int l,int r,int k)&#123; if(l==r)&#123; scanf("%d",&amp;t[k].maxdata); t[k].mindata=t[k].maxdata; return; &#125; int mid=(l+r)/2; make(l,mid,k*2); make(mid+1,r,k*2+1); push_up(l,r,k); return;&#125;Ttree ask(int L,int R,int l,int r,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return t[k]; int mid=(l+r)/2; Ttree res1; if(L&lt;=mid)res1=ask(L,R,l,mid,k*2); else res1=tmp0; Ttree res2; if(R&gt;mid)res2=ask(L,R,mid+1,r,k*2+1); else res2=tmp0; Ttree res=&#123;0&#125;; res.maxdata=max(res1.maxdata,res2.maxdata); res.mindata=min(res1.mindata,res2.mindata); return res;&#125;int main()&#123; tmp0.maxdata=-1e9,tmp0.mindata=1e9; scanf("%d%d",&amp;n,&amp;q); make(1,n,1); for(int i=1;i&lt;=q;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); Ttree ans; ans=ask(x,y,1,n,1); printf("%d\n",ans.maxdata-ans.mindata); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Spoj GSS3]Can you answer these queries III]]></title>
    <url>%2F2018%2F06%2F15%2F%5BSpoj%20GSS3%5DCan%20you%20answer%20these%20queries%20III%2F</url>
    <content type="text"><![CDATA[题目题目描述给定长度为N的数列A，以及M条指令 (N≤500000, M≤100000)，每条指令可能是以下两种之一：“2 x y”，把 A[x] 改成 y。“1 x y”，查询区间 [x,y] 中的最大连续子段和，即 max(x≤l≤r≤y)⁡ { ∑(i=l~r) A[i] }。对于每个询问，输出一个整数表示答案。 输入第一行两个整数N,M 第二行N个整数Ai 接下来M行每行3个整数k,x,y，k=1表示查询（此时如果x&gt;y，请交换x,y），k=2表示修改 输出对于每个询问输出一个整数表示答案。 样例输入123455 31 2 -3 4 51 2 32 2 -11 3 2 样例输出122-1 提示数据范围与约定 对于100%的数据: N≤500000, M≤100000, |Ai|&lt;=1000 题解树存储空间大小这道题与原题略微有点区别，数据输入顺序不一样，以及范围更大了，但是稍微改一下就可以过了。第一个问题，为什么树要开到4*N？首先，我们构造的线段树有可能是完全二叉树（最好情况），叶子节点存储的就是我们每一个点的数据，而我们可以分析下完全二叉树的图。不难发现，我们设节点有n个，那么二叉树的层数为$ log_2(n+1) $而设叶子节点有k个，那么就得到一个k与n的关系：$ k(1-(1/2)^n)=2n $n随k的变化关系曲线为当k趋于无穷大，$ n=2k $ 而对于最坏情况，请参见这篇文章对于最坏的情况我们要开4n的空间来存储。 树存储方式第二个问题，我们要存树，这里可以开一个结构体，里面有四个变量| 变量名称 | 变量作用 ||-|:-:|-|| data | 储存该区间内的最大连续子段和 || ldata | 储存该区间从左端开始的最大和 || rdata | 储存该区间从右端开始的最大和 || sum | 储存该区间内的所有数的和 |这些就够了，不必纪录左子树和右子树。 建树对于每个叶子节点（r==l），我们给他们赋值，而其他节点我们就需要来分析情况了。 sum的值sum的值还用说吗，就是左子树的sum+右子树的sum data的值data是该区间内的最大连续子段和，所以对于data就有几种可能，而我们要做的就是取最大的：1.data=左子树data2.data=右子树data3.data=左子树rdata+右子树ldata ldata和rdata的值ldata储存该区间从左端开始的最大和，所以：1.ldata=左子树ldata2.ldata=左子树sum+右子树rdatardata同理 改变值改变值其实就是建树，只不过因为只改变一个值，所以分治时要么是左子树，要么是右子树，改变完后要注意重新维护其他点的值。 查询值查询值较为复杂，但我们也可以把它看成一个建树的过程。首先，对于我们要查询的范围，如果这个范围大于等于我们分治下去的范围，那么就返回这个范围的值。（实际上就是我们建树时存在这个范围的点）如果这个范围没有点满足，那么我们可以用叶子节点建树来建成我们想要的范围的点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 500000struct Ttree&#123; int data; int ldata,rdata; int sum; &#125;t[MAXN*4],tmp0;int n,m;void push_up(int l,int r,int k)&#123; t[k].sum=t[k*2].sum+t[k*2+1].sum; t[k].data=max(t[k*2].data,t[k*2+1].data); t[k].data=max(t[k*2].rdata+t[k*2+1].ldata,t[k].data); t[k].ldata=max(t[k*2].ldata,t[k*2].sum+t[k*2+1].ldata); t[k].rdata=max(t[k*2+1].rdata,t[k*2+1].sum+t[k*2].rdata); return;&#125;void make(int l,int r,int k)&#123; if(l==r)&#123; scanf("%d",&amp;t[k].data); t[k].ldata=t[k].rdata=t[k].sum=t[k].data; return; &#125; int mid=(l+r)/2; make(l,mid,k*2); make(mid+1,r,k*2+1); push_up(l,r,k); return;&#125;Ttree ask(int L,int R,int l,int r,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return t[k]; int mid=(l+r)/2; Ttree res1; if(L&lt;=mid)res1=ask(L,R,l,mid,k*2); else res1=tmp0;/*目前分治的点的左子树不包含要查询的左端范围，不参与建树，tmp0初始化很小，在取最大值的时候含有它的情况会被忽略掉，但是tmp0.sum初始化还是0*/ Ttree res2; if(R&gt;mid)res2=ask(L,R,mid+1,r,k*2+1); else res2=tmp0;//同理 Ttree res=&#123;0&#125;; res.sum=res1.sum+res2.sum; res.data=max(res1.data,res2.data); res.data=max(res1.rdata+res2.ldata,res.data); res.ldata=max(res1.ldata,res1.sum+res2.ldata); res.rdata=max(res2.rdata,res2.sum+res1.rdata); return res;&#125;void change(int x,int y,int l,int r,int k)&#123; if(l==r)&#123; t[k].data=y; t[k].ldata=t[k].rdata=t[k].sum=t[k].data; return; &#125; int mid=(r+l)/2; if(x&lt;=mid)change(x,y,l,mid,k*2); else change(x,y,mid+1,r,k*2+1); push_up(l,r,k); return;&#125;int main()&#123; tmp0.data=tmp0.ldata=tmp0.rdata=-1e9; scanf("%d%d",&amp;n,&amp;m); make(1,n,1); for(int i=1;i&lt;=m;i++)&#123; int k,x,y; scanf("%d%d%d",&amp;k,&amp;x,&amp;y); if(k==1)&#123; if(x&gt;y)swap(x,y); printf("%d\n",ask(x,y,1,n,1).data); &#125;else&#123; change(x,y,1,n,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>树</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>区间求和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六度空间]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目题目描述“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如下图所示。六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。 假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。 输入格式输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤10000，表示人数）、边数M（≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。 输出格式对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。 输入样例1234567891010 91 22 33 44 55 66 77 88 99 10 输出样例123456789101: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00% 题解简单的一道图的遍历题，这里我用的是bfs（感觉这道题用bfs更简单），超过6次就跳出，这里有一个重点就是如何在队列里判断一轮结束，具体看代码。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 10001bool a[MAXN][MAXN];//这里可以扣一点开个boolbool visited[MAXN];//用来标记访问过的点，注意重置int n,m;int bfs(int v)&#123; int que[MAXN]; int head=1,tail=1; int step=1,last=v;//last存放上一个点访问的最后一个点 int tmp; int count; visited[v]=1; count=1; que[tail++]=v; while(head&lt;tail)&#123; int out=que[head++];//出队元素 for(int i=1;i&lt;=n;i++)&#123; if(visited[i])continue; if(a[out][i])&#123; visited[i]=1; que[tail++]=i; count++; tmp=i;//不断更新，最后访问的点被tmp存到 &#125; &#125; if(out==last)&#123;//如果出队元素等于上个点最后访问的点 step++;//说明这一轮结束，step++，last更新为tmp last=tmp; &#125; if(step==7)break; &#125; return count;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); a[x][y]=a[y][x]=1;//无向图 &#125; for(int i=1;i&lt;=n;i++)&#123;//从每个点开始 memset(visited,0,sizeof(visited));//每次要重置visited double ratio; ratio=bfs(i)*1.0/n*100; printf("%d: %.2f%%\n",i,ratio);//用%%转义字符输出% &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>图的连通</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>邻接矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[YZOJ1370]无聊的锤锤]]></title>
    <url>%2F2018%2F06%2F09%2F%5BYZOJ1370%5D%E6%97%A0%E8%81%8A%E7%9A%84%E9%94%A4%E9%94%A4%2F</url>
    <content type="text"><![CDATA[题目题目描述罗宏明（白客），1988年7月9日出生于中国山东省泰安市，中国内地新生代男演员，毕业于中国传媒大学南广学院。原先是配音员，《搞笑漫画日和》配音团队cucn201的主要成员之一。2013年因出演导演叫兽易小星的搞笑网剧《万万没想到》中的男一号“王大锤”，从而备受关注。 这么火的搞笑剧中，大家是否注意到这样一个剧情(没看过也没关系的)：王大锤要回家过年，上司不让，无奈之下，王大锤就发挥了自己的聪明才智，决定和上司玩个游戏，想着锤锤是个数学白痴，上司欣然答应，胜了就让他回家。游戏是这样的,开始时，白板上有两个不等的整数，他们轮流行动，每次行动必须在白板上写出任意两个已在白板上出现的整数的差且非负，而且这个数字必须是新的，谁再也写不出来就输了。 为了彰显上司魅力，上司让锤锤先开始。上司足够聪明，当然王大锤也不笨，不然会这么火吗？如果你事先知道白板上的数字，聪明的你能推理出王大锤能否回家呢？ 输入测试数据有多组，每组有两个整数，即白板上最初的数字，数据保证在int范围内。 输出每组测试数据输出一行，锤锤能回家就输出“1”，不能输出“0”。 样例输入125 34 8 样例输出1210 题解一开始还打算用暴力，写到一般就打消了这个念头。其实显而易见的是，对于正整数n,m来说,这两个数相减可以得出的所有数x,则 代码12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; int num=gcd(n,m); int c1=n/num;//看它最多能写几个数 int c2=m/num; if(c1&gt;c2)printf("%d\n",c1%2); else printf("%d\n",c2%2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
        <category>最小公倍数与最大公因数</category>
      </categories>
      <tags>
        <tag>欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F09%2FHello%20World%2F</url>
    <content type="text"><![CDATA[123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;Hello, World!&quot;); return 0;&#125;]]></content>
  </entry>
</search>
